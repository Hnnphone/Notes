## HTTP 相关面试题总结

### No.1 HTTP1.0/2.0 & HTTPS 区别

#### HTTP1.0
- 无状态、无连接，每次发送请求的时候，都需要进行一次 TCP 的连接

#### HTTP1.1
- 持久连接，Connection：Keep-Alive
- 请求管道化，服务器必须按照客户端请求的先后顺序依次回送相应的结果
- 增加缓存处理，新的字段如 cache-control
- 增加 Host 字段用以创建多个站点、支持断点传输等

#### HTTP2.0
- 二进制分帧，组成消息的帧可以乱序发送，帧到达对端重新组装，不需要等待前面的帧到达后再发送
- 多路复用（或连接共享），使用一个连接并行发送多个请求和响应的数据流
- 头部压缩，通讯双方各自缓存一份 header fields 表，既避免了重复 header 的传输
- 推送，服务器可以对一个客户端请求发送多个响应

#### HTTPS
- 在 HTTP 协议的基础上添加了 SSL/TLS 协议层，以规避可能出现窃听、伪装和篡改的风险

### No.2 从 url 输入网址后...

#### step 1. DNS 解析：将域名地址为 ip 地址
- 浏览器 DNS 缓存
- 系统 DNS 缓存
- 路由器 DNS 缓存
- 网络运营商 DNS 缓存
- 递归搜索：以 https://blog.baidu.com 为例
    - .com 域名下查找 DNS 解析
    - .baidu 域名下查找 DNS 解析
    - blog 域名下查找 DNS 解析
    - 出错了

#### step 2. TCP 连接：TCP 三次握手
- 第一次握手，由浏览器发起，告诉服务器我要发送请求了
- 第二次握手，由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧
- 第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接收吧

#### step 3. 发送请求
- 请求报文：HTTP 协议的通信内容

#### step 4. 接收响应
- 响应报文

#### step 5. 渲染页面
- 遇见 HTML 标记，浏览器调用 HTML 解析器解析成 Token 并构建成 DOM 树
- 遇见 style/link 标记，浏览器调用 CSS 解析器，处理 CSS 标记并构建 CSSOM 树
- 遇见 script 标记，调用 JavaScript 解析器，处理 script 代码（绑定事件、修改 DOM 树/CSSOM 树）
- 将 DOM 树和 CSSOM 树合并成一个渲染树
- 根据渲染树来计算布局，计算每个节点的几何信息（排版）
- 将各个结点颜色绘制到屏幕上（渲染）

注意：
- 这五个步骤不一定是按照顺序执行，如果 DOM 树或 CSSOM 树被修改了，可能会执行多次重排和重绘
- 往往实际页面中，这些步骤都会执行多次的。

#### step 6. 断开连接：TCP 四次挥手
- 第一次挥手：由浏览器发起的，告诉服务器，我东西（请求报文）发送完了，你准备关闭吧
- 第二次挥手：由服务器发起的，告诉浏览器，我东西（请求报文）接收完了，我准备关闭了，你也准备吧
- 第三次挥手：由服务器发起的，告诉浏览器，我东西（响应报文）发送完了，你准备关闭吧
- 第四次挥手：由浏览器发起的，告诉服务器，我东西（响应报文）接收完了，我准备关闭了，你也准备吧

### No.3 跨域

#### 同源策略
- 是浏览器安全策略
- 协议名、域名、端口号必须完全一致

#### 跨域
- 违背同源策略就会产生跨域

#### 解决跨域
- jsonp cors 服务器代理...
- jsonp 具体解决方案见下
```
function jsonp() {
	// step1. 创建 script 标签
	var script = document.createElement('script');
	// step2. 设置回调函数
	function parseData(res) {
		// 数据请求回来会被触发的函数
		console.log(res.data);
	}	
	// step3. 设置 script 的 src 属性，设置请求地址
	script.src = 'http://localhost:3000?callback=parseData';
	// step4. 让 script 生效
	document.body.appendChild(script);
}
```

#### 其它
- 在浏览器端跨域，可能导致获取到其它网站的敏感信息或者越权操作，所以应当禁止。
- 服务端之所有不存在跨域问题，是因为用户的状态信息都是在浏览器端保存的，服务器只能有自己网站的状态信息。

### No.4 简述 TPC 三次握手和四次挥手的过程

#### 三次握手
**第一次，**
- 客户端发送一个序号 seq=x，标志位 SYN=1 的请求同步连接，其中 x 表明传送数据时的第一个数据字节的序号是 x
- 发送完毕后，客户端进入 SYN_SEND 状态

**第二次，**
- 服务端收到请求报文段后，如同意，则发回确认包应答，即标志位 SYN=1，ACK=1。同时将序号 seq=y 连同确认序号 ack=x+1 一并返回给客户端
- 发送完毕后，服务端进入 SYN_RCVD 状态

**第三次，**
- 客户端收到响应报文段后会再次发送确认包，此时 SYN=0，ACK=1。并将序号 seq 自 x+1 位置开始，确认序号 ack=y+1 发送到服务端
- 发送完毕后，客户端进入 ESTABLISHED 状态，当服务端接收到这个包时，也进入 ESTABLISHED 状态

#### 四次挥手
**第一次，**
- 客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。因为有可能服务器还要发送数据，所以发送自己的序列号 seq=u，等待服务器确认
- 发送完毕后，客户端进入 FIN_WAIT_1 状态

**第二次，**
- 服务端收到后，会发送一个确认包 ACK=1，序号 seq=v，确认序号 ack=u+1 返回给客户端，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接
- 发送完毕后，服务端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态
- 此时从客户端到服务端这个管道通信方向上的连接就释放了，TCP 连接处于半关闭状态

**第三次，**
- 若服务器已经没有要向客户端发送的数据，则开始准备好关闭连接，即向客户端发送结束连接请求 FIN 置为 1，ACK=1，seq=w，ack=u+1，等待可能出现服务端要求重传的 ACK 包
- 发送完毕后，服务端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK

**第四次，**
- 客户端接收到来自服务端的关闭请求，发送一个确认包 ACK=1，seq=u+1，ack=w+1，并进入 TIME_WAIT 状态。
- 服务端接收到这个确认包之后，关闭连接，进入 CLOSED 状态
- 客户端等待了某个固定时间(2MSL，两个最大报文段生命周期)之后，没有收到服务端的 ACK，认为服务端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态

#### 为什么需要三次握手和四次挥手
- 信道不可靠，但是通信双发需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含什么信息，三次通信是理论上的最小值。想象一下，如果没有第三次握手，那服务端会不会在某种客户端的异常情况下持续等待？
- TCP是全双工模式，当一端发起断开连接的请求后，另一端未必会马上关闭通信管道，只有当无需发送数据时，才会发起中断请求。并且在通常情况下，被动方总是先于主动方关闭连接。

### No.5 报文

#### 请求格式
- 请求行：包含请求方法、URI、HTTP 版本信息
- 请求首部字段
- 请求内容实体

#### 响应格式
- 状态行：包含 HTTP 版本、状态码、状态码的原因短语
- 响应首部字段
- 响应内容实体

#### 首部字段 Content-Type
由于 GET 请求并不存在请求实体部分，因此请求首部不需要设置 Content-Type 字段，下面以 POST 请求为例
- raw 原始类型，可以上传任意格式的文本，比如 text/plain、application/json、text/html
- appliction/x-www-form-urlencoded，将表单内的数据转换拼接成 key-value 对（非 ASCII 码会进行编码）
- multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分割符分开。既可以上传键值对，也可以上传文件

### No.6 浏览器缓存
简单来说，浏览器缓存就是把一个已经请求过的 Web 资源（如 html 页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。

#### 为什么使用缓存？
1. 减少网络带宽消耗
2. 降低服务器压力
3. 减少网络延迟，加快页面打开速度

#### 浏览器端采用的缓存规则？
1. 新鲜度（过期机制），也就是缓存副本有效期
2. 校验值（验证机制），服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。

#### Cache-Control & Expires
- Exprires：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期
- Cache-control：max-age，表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题
- 如果同时设置的话，Cache-control 优先级高于 Expires

#### Last-Modified & ETag
- Last-modified/If-Modified-Since：第一次请求的时候服务端返回 Last-modified 表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头 If-Modified-Since，表示资源上次的修改时间，服务端拿到这两个字段进行对比。
- ETag/If-None-Match：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回 If-None-Match 标识是否表示匹配。
- Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304

#### 两种规则是如何搭配的？
- 配置 Last-Modified/ETag 的情况下，浏览器再次访问统一 URI 的资源，还是会发送请求到服务器询问文件是否已经修改
- Cache-Control/Expires 则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，是不会发送任何请求的。
- 两者一起使用时，Cache-Control/Expires 的优先级要高于 Last-Modified/ETag